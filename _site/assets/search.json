

[
  
  
    
    
      {
        "title": "DWA1001 - Euclidean Algorithm With Maths",
        "excerpt": "Euclidean Algorithm to calculate GCD efficiently.\n",
        "content": "GCD of two numbers is the largest number that divides both of them. A simple way to find GCD is to factorize both numbers and multiply common factors.\n\nHow do you find the greatest common divisor (gcd) of two integers a, b ?\n\nWe denote the greatest common divisor of a and b by gcd(a, b), or sometimes even just (a, b) . If (a, b) = 1 we say a and b are coprime.\n\nThe most common answer is to list all the divisors a and b , and look for the greatest one they have in common. As shown in the below image,\n\n\n\nBy subtracting the smaller number from the bigger (i.e) Reducing the larger number won’t affect the GCD. \n\nProof:\n\nConsider, GCD of two numbers a = 25, b = 5 . So if we are subtracting the larger number by the smaller one , we get, \n\n 25 - 5 = 20 \nStill the GCD of 20,5 is 5 . \n\nSo if we keep subtracting repeatedly the larger of two, we end up with GCD. Now instead of subtraction, if we divide smaller number, the algorithm stops when we find remainder 0.\n\nHence we can find gcd(a, b) by doing something that most people learn in primary school: division and remainder. We give an example and leave the proof of the general case to the reader. \n\nSuppose we wish to compute gcd(27, 33) First, we divide the bigger one by the smaller one:\n\n 33 = 1 x 27 + 6  \n\nThus  gcd(33, 27) = gcd(27,6). Repeating this trick:\n\n 27 = 4 x 6 + 3 \n\nand we see  gcd(27,6) = gcd(6, 3).\n\nFinally,\n\n 6 = 2 x 3 + 0 \n\nSo since 6 is a perfect multiple of 3, gcd(6,3) = 3 , and we have found that   gcd(33,27) = 3\n\nTime Complexity: O(Log min(a,b))\n\n\nCode :\ndef gcd(a, b):\n\tif (b == 0):\n\t\treturn a\n\telse:\n\t\treturn gcd(b, a%b)\n\n\n\n\nFollow us on Instagram to receive more content :  Instagram \n",
        "url": "//algorithm/2020/05/17/DWA1001-Eculidean_Algorithm/"
      },
    
      {
        "title": "Sample Event",
        "excerpt": "Euclidean Algorithm to calculate GCD efficiently.\n",
        "content": "GCD of two numbers is the largest number that divides both of them. A simple way to find GCD is to factorize both numbers and multiply common factors.\n\nHow do you find the greatest common divisor (gcd) of two integers a, b ?\n\nWe denote the greatest common divisor of a and b by gcd(a, b), or sometimes even just (a, b) . If (a, b) = 1 we say a and b are coprime.\n\nThe most common answer is to list all the divisors a and b , and look for the greatest one they have in common. As shown in the below image,\n\n\n\nBy subtracting the smaller number from the bigger (i.e) Reducing the larger number won’t affect the GCD. \n\nProof:\n\nConsider, GCD of two numbers a = 25, b = 5 . So if we are subtracting the larger number by the smaller one , we get, \n\n 25 - 5 = 20 \nStill the GCD of 20,5 is 5 . \n\nSo if we keep subtracting repeatedly the larger of two, we end up with GCD. Now instead of subtraction, if we divide smaller number, the algorithm stops when we find remainder 0.\n\nHence we can find gcd(a, b) by doing something that most people learn in primary school: division and remainder. We give an example and leave the proof of the general case to the reader. \n\nSuppose we wish to compute gcd(27, 33) First, we divide the bigger one by the smaller one:\n\n 33 = 1 x 27 + 6  \n\nThus  gcd(33, 27) = gcd(27,6). Repeating this trick:\n\n 27 = 4 x 6 + 3 \n\nand we see  gcd(27,6) = gcd(6, 3).\n\nFinally,\n\n 6 = 2 x 3 + 0 \n\nSo since 6 is a perfect multiple of 3, gcd(6,3) = 3 , and we have found that   gcd(33,27) = 3\n\nTime Complexity: O(Log min(a,b))\n\n\nCode :\ndef gcd(a, b):\n\tif (b == 0):\n\t\treturn a\n\telse:\n\t\treturn gcd(b, a%b)\n\n\n\n\nFollow us on Instagram to receive more content :  Instagram \n",
        "url": "//events/2020/05/17/DWA1001-Eculidean_Algorithm/"
      },
    
      {
        "title": "DWA1002 - Kadane's Algorithm With Maths",
        "excerpt": "Kadanes Algorithm to calculate maximum sum of continous subarray in an array.\n",
        "content": "Consider a Problem, to calculate the maximum sum of continous sub array from the given array. There are two ways of approaching it. \n\n\n  Bruteforce Method:\n    \n      Example Consider the following array: \n [-1, -3, 4, 5, -6].\n      By Bruteforcing we can see that the sum of elements is 9.\n (i.e) the maixmum sum of largest continous sub array is 9.\n      Time Complexity :  O(n^2)\n      Before going to the kadane algorithm we will see how that is been implemented in brute force.\n      So at the first index, the max value is arr[0]. (i.e) -1.\n        \n          For the first index it is -1\n        \n      \n      During the Second index,\n        \n          For the second index it could be\nmax (\n[-1 -3],\n[-3]\n)\nHence max = -1; ( not greater than prev. max value )\n        \n      \n      During the third index it could be,\n        \n          max (\n[-1 -3 +4]\n[-3 +4],\n[4]\n)\nHence max = 4; ( not greater than prev. max value )\n        \n      \n      During the fourth index it could be,\n        \n          max (\n[-1 -3 +4 +5]\n[-3 +4 +5],\n[4 + 5]\n[5]\n)\nHence max = 9; ( not greater than prev. max value )\n        \n      \n      During the fifth index it could be,\n        \n          max (\n[-1 -3 +4 +5 -6]\n[-3 +4 +5 -6],\n[4 + 5 -6]\n[5 -6]\n[-6]\n)\nHence max = 9; ( current max value is 3 which is lesser than previous max value )\n        \n      \n    \n\n    Hence, the worst case in brute force approach is O(n^2).\n By using kadane’s algorithm, we can reduce it to O(n) time.\n\n    Python Implementation:\n\n         arr = [-1, -3, 4, 5, -6]\n     maxx = arr[0] \n     for itr in range(len(arr)-1): \n          temp = 0 \n          for ctr in range(itr+1): \n              temp += arr[itr+1-ctr] \n              if( maxx &lt; temp ): \n                  maxx = temp \n     print(maxx)\n    \n\n    \n  \n  Kadane's Algorithm :\n    \n      The loc_max is either the element at the current index or the current element combined with previous loc_max.\n      We continue to calculate the above for all the elements in the array. After that we will pick the maximum from the loc_max array.\n      The idea is to maintain maximum (positive sum) sub-array “ending” at each index of the given array. This subarray is either empty (in which case its sum is zero) or consists of one more element than the maximum subarray ending at the previous index.\n      We can consider the same array , \n arr = [-1, -3, +4, +5, -6]\n      Initially,\n        \n          loc_max = arr[0]\nglobal_max = arr[0]\n        \n      \n      During second iteration,\n        \n          Pass 1:\nloc_max = max( arr[1], (-1 + arr[1]) ) = max[-1, -4] = -1\nglobal_max = max( -1, -1 ) = -1\n        \n      \n      During third iteration,\n        \n          Pass 2: \nloc_max = max[ arr[2] , (-1 + arr[2]) ] = max ( 4, 1 ) = 4\nglobal_max = max(4, -1) = 4\n        \n      \n      During fourth iteration,\n        \n          Pass 3:\nloc_max = max[ arr[3], (4 + 5) ] = max (5, 9) = 9\nglobal_max = max(9, 4) = 9\n        \n      \n      During fifth iteration,\n        \n          Pass 4: \nloc_max = max[ arr[4], (-6 + 5) ] = max( 5, -1 ) = 5\nglobal_max = max( 5, 9 ) = 9\n        \n      \n      Hence the maximum sum of continous sub array of the given array is 9.\n      Time Complexity :  O(n) \n      Space Complexity :  O(1) \n      Python Implementation :\n    \n\n     def max_of(a, b):\n     if( a &gt; b):\n         return a\n     else: \n         return b\n\n\n def kadane_max(arr):\n     length = len(arr)\n     loc_max = arr[0]\n     global_max = arr[0]\n     for itr in range(length - 1):\n         loc_max = max_of( arr[itr+1], loc_max+arr[itr+1] ) \n         global_max = max_of(loc_max , global_max)\n     return global_max\n\n print( kadane_max([-1,-3,4,5-6]) ) \n    \n  \n\n\n\n\nFollow us on Instagram to receive more content :  Instagram \n",
        "url": "//algorithm/2020/05/18/DWA1002-Kadanes_Algorithm/"
      },
    
      {
        "title": "DWA1003 - Sieve Of Eratosthenes Algorithm With Maths",
        "excerpt": "Sieve of Eratosthenes Algorithm to find all the primes smaller than n.\n",
        "content": "Sieve of Eratosthenes is a simple and ancient algorithm used to find the prime numbers up to any given limit. It is one of the most efficient ways to find small prime numbers.\n\nKeywords:\n\n\n  \n    Prime : A Prime number is a natural number greater than 1 , which we can represent it in a product form by only two ways. (i.e) For 3 =&gt; 3 * 1 , 1 * 3. A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.\n  \n  \n     CoPrime: All the other numbers other than prime is a coprime.\n  \n\n\nWorking:\n\nThe algorithm is very simple: at the beginning we write down all numbers between 2 and n. We mark all proper multiples of 2 (since 2 is the smallest prime number) as composite.\nSo a proper multiple of a number x, is a number greater than x and divisible by x.\nSo we will be finding the next number which is not marked as composite, in our case it is 3. So we will be marking 3 as prime and all the multiples of 3 as co-primes.\n\n\n\n\nThe Idea behind it is : \nA number is prime, if none of the smaller prime numbers divides it. Since we iterate over the prime numbers in order, we already marked all numbers, who are divisible by at least one of the prime numbers, as divisible. Hence if we reach a cell and it is not marked, then it isn’t divisible by any smaller prime number and therefore has to be prime.\n\n Implementation :\n\ndef sieve_eratosthenes(n):\n    all_numbers = [ True for itr in range(n+1) ]\n    start = 2\n    result = []\n    # Start from 2 till n+1.\n    for itr in range(start, n+1):\n    \tif( all_numbers[itr] == True ):\n    \t\t# for range( from, to, number of steps. Like i+=2 in other lang. )\n    \t\tresult.append( itr )\n    \t\tfor ctr in range(itr*itr, n+1, itr):\n    \t\t\tall_numbers[ctr] = False\n    return result\nprint(sieve_eratosthenes(100))\n\n\n\n\nFollow us on Instagram to receive more content :  Instagram \n\n",
        "url": "//algorithm/2020/05/19/DWA1003-sieve-of-eratosthenes/"
      },
    
      {
        "title": "DWA1004 - Binary Search Algorithm With Maths",
        "excerpt": "Binary Search Algorithm , to search a key from the given array of Values.\n",
        "content": "Binary Search delivers better performance than Sequential Search because it starts with a collection whose elements are already sorted.\n\nBinary Search divides the sorted collection in half until the sought-for item is found, or until it is determined that the item does not exist in the collection.\n\nIt works better than  Linear Search .\n\nPreconditions:\n\n  \n    Array needs to be in Sorted Order.\n  \n\n\nInput:\nThe Input will be an array A which is totally in ordered form, which means in given two index positions i, j where A[i] &lt; A[j]  ( Since the list is sorted ) on i &lt; j.\n\nOutput:\nThe Output is either true or false.\n\nThere are several data structures available to implement. But the better one is  Binary Search Tree .\n\nImplementation:\nWe basically ignore half of the elements just after one comparison.\n\n\n  Compare x with the middle element.\n  If x matches with middle element, we return the mid index.\n  Else If x is greater than the mid element, then x can only lie in right half subarray after the mid element. So we recur for right half.\n  Else (x is smaller) recur for the left half.\n\n\nBinary Search adds a small amount of complexity for large performance gains. The complexity can increase when the collection is not stored in a simple in-memory data structure, such as an array.\n\nImplementation:\ndef binary_search(A, key): \n        length = len(A) \n         low = 0 \n         high = length - 1 \n         while ( low &lt;= high ): \n             mid = ( low+high )//2 \n             if ( key &lt; A[mid]): \n                 high = mid - 1 \n             elif ( key &gt; A[mid]): \n                 low = mid + 1 \n             else: \n                 return (True,mid) \n         return (False,-1) \n          \n\nIf the value is present in the given array it will return True and the index of the element.\n\nIf the value is not present in the given array it will return False and -1 representing not found.\n\nScreenshots:\n\n\n\n\n\nA large collection might need to be kept in secondary storage,\nsuch as a file on a disk. In such a case, the i th element is accessed by its offset location within the file. Using secondary storage, the time required to search for an element is dominated by the costs to access the storage; other solutions related to Binary Search may be appropriate.\n\nTime Complexity :\nBest Case : O(1) \nAverage, Worst Case : O(log n)\n\nFollow us on Instagram to receive more content :  Instagram \n",
        "url": "//algorithm/2020/05/20/DWA1004-Binary-Search-Algorithm/"
      },
    
      {
        "title": "DWA1005 - Singly linked List Data Structure and Implementation.",
        "excerpt": "Singly linked list design, types and its implementation.\n",
        "content": "Keywords :\n\n  \n    Node : Its descended from the latin “nodus” meaning “knot”, comes from graph theory in math. A graph is a generalized way to describe a bunch of things that have relationships. The things are called nodes, the relationships connecting the nodes are called edges. Consider node as a data structure to store the reference to the value or the actual value(object) and the references to other nodes.\n  \n  \n    Pointers : A pointer is a variable whose value is the address of another variable, i.e., direct address of the memory location.\n  \n\n\nA linked list is a linear data structure where each element is a separate object. Linked list elements are not stored at contiguous location; the elements are linked using pointers.\n\nSingly Linked List:\n\nIt’s a collection of Nodes that collectively form a linear sequence. Each node stores a reference to an object that is an element of the sequence, as well as reference to the next node of the list.\n\n\n\nThe list instance maintains a member named head that identifies\nthe first node of the list, and in some applications another member named tail that identifies the last node of the list. The None object is denoted as Ø. None object contains no reference to the value.\n\nThe first and last node of a linked list are known as the head and tail of the list, respectively. By starting at the head, and moving from one node to another by following each node’s next reference, we can reach the tail of the list. We can identify the tail as the node having None as its next reference. This process is commonly known as traversing the linked list. Because the next reference of a node can be viewed as a link or pointer to another node, the process of traversing a list is also known as link hopping or pointer hopping.\n\nA linked list’s representation in memory relies on the collaboration of many objects. Each node is represented as a unique object, with that instance storing a reference to its element and a reference to the next node (or None).\n\nAnother object represents the linked list as a whole. Minimally, the linked list instance must keep a reference to the head of the list. Without an explicit reference to the head, there\nwould be no way to locate that node (or indirectly, any others).\n\n\n\nThere is not an absolute need to store a direct reference to the tail of the list, as it could otherwise be located by starting at the head and traversing the rest of the list.\n\nHowever, storing an explicit reference to the tail node is a common convenience to avoid such a traversal. In similar regard, it is common for the linked list instance to keep a count of the total number of nodes that comprise the list (commonly described as the size of the list), to avoid the need to traverse the list to count the nodes.\n\nAn important property of a linked list is that it does not have a predetermined fixed size; it uses space proportionally to its current number of elements.\n\nImplementation:\n\nSimple Insertion and displaying.\n\n#include &lt;iostream&gt;\nusing namespace std;\n// Node Structure\nstruct Node {\n   // Data value.\n   int data; \n   // Reference to next node.\n   struct Node *next; \n}; \n// Objects\nstruct Node* head = NULL;   \n\n// Insert will happen at the start.\nvoid insert(int new_data) { \n   struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); \n   new_node-&gt;data = new_data; \n   new_node-&gt;next = head; \n   head = new_node; \n} \n\nvoid display() { \n   struct Node* ptr;\n   ptr = head;\n   while (ptr != NULL) { \n      cout&lt;&lt; ptr-&gt;data &lt;&lt;\" \"; \n      ptr = ptr-&gt;next; \n   } \n} \nint main() { \n   insert(3);\n   insert(1);\n   insert(7);\n   insert(2);\n   insert(9);\n   cout&lt;&lt;\"The linked list is: \";\n   display(); \n   return 0; \n} \n\nOutput:\n\n\nInsertion in a given location:\n\nHere you can specify the position to insert the data.\n\nvoid insert_in(int pos, int new_data){\n   struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); \n   struct Node* prev = (struct Node*) malloc(sizeof(struct Node));\n   struct Node* cur = head;\n   \n   new_node-&gt;data = new_data; \n   new_node-&gt;next = NULL;\n   for (int itr = 0;itr&lt;pos;itr++){\n      prev = cur;\n      cur = cur-&gt;next;\n   }\n   new_node-&gt;next = cur;\n   prev-&gt;next = new_node;\n\n}\n\n\n\nAppending the value: \n\nvoid append( int new_data) {\n   struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); \n   struct Node* last = head;\n   new_node-&gt;data = new_data; \n   new_node-&gt;next = NULL;\n   if( head -&gt; next == NULL ){\n      head -&gt; next = new_node;\n      return ;\n   } \n   while( last-&gt;next != NULL ){\n      last = last -&gt; next;\n   }\n   last-&gt;next = new_node;\n}\n\nAppending will insert the value at the end.\n\nEntire Code:\n\n#include &lt;iostream&gt;\nusing namespace std;\n// Node Structure\nstruct Node {\n   // Data value.\n   int data; \n   // Reference to next node.\n   struct Node *next; \n}; \n// Objects\nstruct Node* head = NULL;   \n\nvoid insert(int new_data) { \n   struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); \n   new_node-&gt;data = new_data; \n   new_node-&gt;next = head; \n   head = new_node; \n} \n\nvoid append( int new_data) {\n   struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); \n   struct Node* last = head;\n   new_node-&gt;data = new_data; \n   new_node-&gt;next = NULL;\n   if( head -&gt; next == NULL ){\n      head -&gt; next = new_node;\n      return ;\n   } \n   while( last-&gt;next != NULL ){\n      last = last -&gt; next;\n   }\n   last-&gt;next = new_node;\n}\n\nvoid insert_in(int pos, int new_data){\n   struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); \n   struct Node* prev = (struct Node*) malloc(sizeof(struct Node));\n   struct Node* cur = head;\n   \n   new_node-&gt;data = new_data; \n   new_node-&gt;next = NULL;\n   for (int itr = 0;itr&lt;pos;itr++){\n      prev = cur;\n      cur = cur-&gt;next;\n   }\n   new_node-&gt;next = cur;\n   prev-&gt;next = new_node;\n\n}\n\nvoid display() { \n   struct Node* ptr;\n   ptr = head;\n   while (ptr != NULL) { \n      cout&lt;&lt; ptr-&gt;data &lt;&lt;\" \"; \n      ptr = ptr-&gt;next; \n   } \n} \nint main() { \n   insert(3);\n   insert(1);\n   insert(7);\n   insert(2);\n   insert(9);\n   append(10);\n   insert_in(2,300);\n   cout&lt;&lt;\"The linked list is: \";\n   display(); \n   return 0; \n} \n\n\nOutput:\n\n\n\nReferences:\n\n  Node -  What does a node in coding mean ?\n  Tutorials Point -  Link \n\n\n",
        "url": "//data%20structures/2020/05/21/DWA1005-Linked-List-Data-Structure/"
      },
    
      {
        "title": "DWA1006 - Insertion Sorting Algorithm.",
        "excerpt": "Insertion sort is the simple and efficient comparison sort.\n",
        "content": "Insertion sort is a simple and efficient comparison sort. In this algorithm, each iteration removes an element from the input data and inserts it into the correct position in the list being sorted.\n\nInsertion Sort repeatedly invokes an insert helper function to ensure A[0, i] is properly sorted; eventually, i reaches the rightmost element, sorting A entirely.\n\nThe choice of the element being removed from the input is random and this process is repeated until all input elements have gone through.\n\nExplanation:\n\n  Consider we are having an array,\n    \n      arr = [3,1,10,2,8]\n      \n    \n  \n  \n    We are iterating through each element and will be checking whether the current element is greater than elements in the left side of the curr element. If not, we will be swapping the elements.\n  \n  \n    1st Iteration:\n\n     Cur. Element = 3\n So on the first iteration, no elements are present to the left of 3.\n arr = [ 3, 1, 10, 2, 8 ]\n    \n  \n  2nd Iteration:\n     Cur. Element = 1\n Now there is an element to the left of 1 ( 3 ). So we will be swapping 3 and 1.\n so the resultant array will be,\n arr = [ 1, 3, 10, 2, 8]\n    \n  \n  3rd Iteration:\n     Cur. Element = 10\n Now, elements 1, 3 are to the left of 10. Since they are in order we need not to swap.\n arr = [1, 3, 10, 2, 8]\n    \n  \n  4th Iteration:\n     Cur. Element = 2\n Now there are elements to the left of 2 which are greater than 2. \n arr = [1, 3, 2, 10, 8]\n arr = [1, 2, 3, 10, 8]\n    \n  \n  5th Iteration:\n     Cur. Element = 8\n Now there is an element 10 to the left of 8 , which is greater than 8.\n We will be swapping 8 and 10.\n arr = [1, 2, 3, 8, 10]\n    \n  \n  So, now we will be having the sorted array.\n\n\nCharacteristics of Insertion Sort:\n\n  \n    Insertion Sort requires very little extra space to function; it only needs to reserve space for a single element.\n  \n  \n    The optimal performance occurs when the array is already sorted, and arrays sorted in reverse order produce the worst performance for Insertion Sort.\n  \n  \n    Insertion sort is used when the data is nearly sorted (due to its adaptiveness) or when the input size is small (due to its low overhead).\n  \n  \n    Insertion sort is almost linear for partially sorted input.\n  \n\n\nImplementation:\ndef insertion_sort(arr):\n    for itr in range(1, len(arr)): \n        cur = arr[itr]  \n        ctr = itr - 1\n        while ctr &gt;= 0 and cur &lt; arr[ctr] : \n                arr[ctr + 1] = arr[ctr] \n                ctr -= 1\n        arr[ctr + 1] = cur\n    print (arr)\n\narr = [3,1,10,2,8]\ninsertion_sort(arr) \n\n\n\nOutput:\n\n\n\nAnalysis:\n\n\n   Worst Case Analysis  : O(n2)\n  Best Case Complexity  : O(n)\n   Average Case Complexity  : O(n2)\n\n\nFollow us on Instagram to support us and receive more content :  Instagram \n\n",
        "url": "//algorithm/2020/05/22/DWA-1006-Insertion-Sort/"
      },
    
      {
        "title": "DWA1007 - Square Root of a number without built-in function",
        "excerpt": "To Find the Square Root of a number without using built-in function.\n",
        "content": "This Algorithm is a combination of Newton’s Method and\n\nThe square root of a positive number b can be computed with Newton’s formula:\nwhere x above starts with a “reasonable” guess. In fact, you can always start with b or some other value, say 1.\n\nWith b and a guess value x, a new guess value is computed with the above formula. This process continues until the new guess value and the current guess value are very close. In this case, either one can be considered as an approximation of the square root of b.\n\n\n\nStep 1 : Get the input value input_val . Let\ninput_value = int(input())\n\n\n\nStep 2 : Find the Dividend of the input number. (i.e) find the integer part of the sqrt.\nfor itr in range(input_value/2):\n    if ((itr*itr)&lt;= input_value and  input_value &lt; ((itr+1)*(itr+1)) ):\n        dividend = itr\n        break\n\n\n\nStep 3 : Apply Newtons Method,\ndef repeat_this(dividend):\n    val1 = ( input_value / dividend )\n    val2 = ( dividend + val1 ) / 2\n\n\nBy repeating the third step, we will be getting more approximation of the value.\n\n\n  for eg:\nlet the no. be 93\nthe no. 93 is inbetween (99) and (1010) . so all the no. inbetween 81 and 100 has the sqrt &gt; to be starting with 9 and preceded by floating points. [here dividend is 9]\nlet d=(a/dividend) (ie. d=93/9=10.3333333)\nz=(9+10.333333)/2=9.666666667\nx=93/9.66666667=9.62089655\ng=(9.62089655+9.666666667)/2    =    9.64378178\n\n\ninput_value = int(input())\nfor itr in range(input_value//2):\n    if ((itr*itr)&lt;= input_value and  input_value &lt; ((itr+1)*(itr+1)) ):\n        dividend = itr\n        break\ndef repeat_this(dividend):\n    val1 = ( input_value / dividend )\n    val2 = ( dividend + val1 ) / 2\n    return val2\ndividend = repeat_this(dividend)\ndividend = repeat_this(dividend)\ndividend = repeat_this(dividend)\nprint(dividend)\n\nimport math\nprint(math.sqrt(input_value))\n\n\nOutput:\n\n(base) syedjafer@syedjafer:~/Documents/DWA/SQRT$ python main.py \n50\n7.0710678118654755\n7.0710678118654755\n(base) syedjafer@syedjafer:~/Documents/DWA/SQRT$\n",
        "url": "//algorithm/2020/05/23/Algorithm-for-calculating-sqrt-of-a-number-without-built-in-function/"
      },
    
      {
        "title": "DWA1008 - Selection Sorting Algorithm.",
        "excerpt": "Selection sort is an in-place sorting algorithm.\n",
        "content": "Selection sort is an in-place sorting algorithm.\nSelection sort works well for small files. It is used for sorting the files with very large values and small keys. This is because selection is made based on keys and swaps are made only when required.\n\nSelection Sort is the slowest of all the sorting algorithms.\n\nIn Selection Sort, for every iteration we will be finding the maximum value. That max value will be swapped with the right most value of the array ( in case of ascending ). For the same ascending we can do it in reverse manner, like, finding the smallest element in the array and swapping it with the left most value of the array.\n\nAlgorithm:\n\nStep 1 − Set MAX to location n-1 ( Array of length n )\nStep 2 − Search the maximum element in the list\nStep 3 − Swap with value at location MAX\nStep 4 − Increment MAX to point to next element\nStep 5 − Repeat until list is sorted\n\n\nExplanation:\n\n  Consider we are having an array,\n     arr = [ 1, 9, 10, 5, 19, 2 ]\n    \n  \n  1st Iteration,\n     arr = [ 1, 9, 10, 5, 19, 2]\n max_ptr = index(5)\n Now iterate the entire array, and find the maximum element in the array.\n Now swap the max_element with the value in max_ptr index.\n\n In our Example, \n max_ptr = arr[5]  =&gt; 2\n max_value of arr[0,5] = 19 \n Swapping those 2 values.\n arr = [ 1, 9, 10, 5, 2, 19 ]\n max_ptr = index(5) - 1\n    \n  \n  2nd Iteration,\n     arr = [ 1, 9, 10, 5, 2, 19 ]\n max_ptr = index(4) =&gt; val 2\n max_value of arr[0,4] = 10\n Swapping those 2 values, \n arr = [ 1, 9, 2, 5, 10, 19 ]\n max_ptr = index(4) - 1\n    \n  \n  3rd Iteration,\n     arr = [ 1, 9, 2, 5, 10, 19 ]\n max_ptr = index(3) =&gt; val 5\n max_value of arr[0,3] = 9\n Swapping those 2 values,\n arr = [ 1, 5, 2, 9, 10, 19 ]\n max_ptr = index(3) - 1\n    \n  \n  4th Iteration,\n     arr = [ 1, 5, 2, 9, 10, 19 ]\n max_ptr = index(2) =&gt; val 2\n max_value of arr[0,2] = 5\n Swapping those 2 values,\n arr = [1, 2, 5, 9, 10, 19]\n max_ptr = index(2) - 1 \n    \n  \n  5th Iteration,\n     arr = [1, 2, 5, 9, 10, 19]\n max_ptr = index(1) =&gt; val 2\n max_value of arr[0,1] = 2\n Since they are same positions we can neglect it.\n arr = [ 1, 2, 5, 9, 10, 19 ]\n Last element will be sorted by default.\n    \n  \n  So the resultant array is,\n     arr = [ 1, 2, 5, 9, 10, 19]\n    \n  \n\n\nCharacteristics of Selection Sort:\n\n  Selection Sort is the slowest of all the sorting algorithms.\n  It requires quadratic time even in the best case (i.e., when the array is already sorted).\n\n\nImplementation:\n\ndef selection_sort(arr): \n        length = len(arr) \n        while(length&gt;=1): \n            max_value = length - 1 \n            for itr in range(length): \n                if( max_value &lt; arr[itr]): \n                    max_value = arr[itr] \n                    max_index = itr \n            arr[length-1] , arr[max_index] = max_value, arr[th-1] \n            print(arr) \n            length -= 1 \n\n\n\nOutput:\n\n\nAnalysis:\n\n\n   Worst Case Analysis  : O(n2)\n  Best Case Complexity  : O(n2)\n   Average Case Complexity  : O(n2)\n\n\nFollow us on Instagram to support us and receive more content :  Instagram \n\n",
        "url": "//algorithm/2020/05/23/DWA1008-Selection-Sort/"
      },
    
      {
        "title": "DWA1010 - Counting Sort Algorithm.",
        "excerpt": "Algorithm to sort based on occurence of the elements.\n",
        "content": "Counting sort is a sorting algorithm that sorts the elements of an array by counting the number of occurrences of each unique element in the array. Counting sort is a stable sorting technique.\n\nExplanation:\n\nThe count is stored in an temporary array and the sorting is done by mapping the count as an index of the temporary array.\n\nIt works by counting the number of objects having distinct key values (kind of hashing). Then doing some arithmetic to calculate the position of each object in the output sequence.\n\n\n  Consider the array,\n    arr = [1, 4, 5, 4, 9, 10]\n    \n  \n  Now we will generate a temporary array with length of 256 (ASCII Length) or to the length of max element of the original array. We will create an temporary array with the length of the max value of the original array + 1.\n    max(arr) =&gt; 10\ntemp_arr = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\n    \n  \n  Now we will iterate through the values of the original array. By iterating we can increase the count in the temporaray array corresponding to the value.\n\n\n(i.e) temp_arr[arr_val] += 1\n\narr[0] is 1; so what we will be doing is, increasing the temp_arr[1] by 1. Similarly, arr[1] is 4 so i will be incrementing the temp_arr[4] by 1. \nAlso again another 4 is present in the original array. During that iteration it will be doing the same. Incrementing temp_arr[4] by 1.\n\n4.Now we will be iterating through the temp_arr from index 1. So we will be adding the current value with the previous value.\n\ntemp_arr[1] = temp_arr[1] + temp_arr[0]\ntemp_arr[cur_value] = temp_arr[cur_value] + temp_arr[previous_val]\n\nresultant array would be, \ntemp_arr = [0, 1, 1, 1, 3, 4, 4, 4, 4, 5, 6]\n\n\n5.Then we can create the output array of length of the original array.\n\noutput = len(arr)\n\n\nBy iterating through the original array ( cur_element ), check the value of the temp_array[cur_element].\nThe index of the cur_element in the output array  = temp_array[cur_element] - 1\n\nfor (itr = 0; itr&lt; len(arr); itr++){\n\tcur_element = arr[itr];\n\tindex = temp_arr[cur_element] - 1;\n\toutput[index] = cur_element;\n\ttemp_arr[cur_element] = temp_arr[cur_element] - 1;\n}\n\nresultant output array will be, \n[1, 4, 4, 5, 9, 10]\n\n\n\nImplementation:\n\ndef counting_sort(arr): \n\tmax_element = max(arr)\n    output = [0 for i in range(len(arr))] \n    temp_array = [0 for i in range(max_element)] \n  \tfor item in arr:\n  \t\ttemp_array[item] += 1\n\n  \tfor itr, item in enumerate(temp_array):\n  \t\tif(itr &gt; 0):\n\t  \t\ttemp_array[itr] = temp_array[itr] + temp_array[itr-1]\n  \n    for itr, item in enumerate(arr):\n    \tindex = temp_array[item] - 1\n    \toutput[index] = item\n    \ttemp_array[item] -= 1\n    return output  \n\narr = [1, 4, 5, 4, 9, 10]\nprint( counting_sort(arr) )\n\n\nOutput:\n\n\n\nTime Complexity:\n\n  Best Case : O(n+k)\n  Average Case : O(n+k)\n  Worst Case : O(n+k)\n\n\nReferences:\n\n\n  Growingwithweb :  Link \n  Programmiz : Link\n\n\nFollow us on Instagram to support us and receive more content :  Instagram \n",
        "url": "//algorithm/2020/05/25/DWA1010-Counting-Sort-Algorithm/"
      },
    
      {
        "title": "DWA1011 - Singleton Design Pattern.",
        "excerpt": "A Design Pattern to maintain only one object at any point of time.\n",
        "content": "The singleton pattern is one of the simplest design patterns.The singleton pattern is a design pattern that restricts the instantiation of a class to one object.\n\nSingleton is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance.\n\nExample:\n\n\n  \n    Simple deck of cards : \nWhen most of us sit down to play a few games of poker with our buddies, we often play using a single entity known as the deck. This typically consists of 52 cards in total, made up of thirteen ranks of four suits each. When a hand is dealt around the table, all cards are obtained from that single shuffled instance of the deck. Once the hand is over and you’ve (hopefully) taken your friends for all they’re worth, all 52 cards are gathered up and shuffled back into that same single instance of the deck, then a new hand is dealt from it. Repeat ad nauseam until all money is lost and/or drunkenness overtakes you.\n  \n  \n     Government :\nGovernment is a single entity. We can refer as Currently its the “Governement of X “. Value of X ( Ministers ) may change but still its the same Government.\n  \n\n\nWhen not to use this Pattern ?\n\nWhenever your class is dealing with some specific identifier to the objects, at that time we should not use this pattern. \nExample, \nConsider the Student class, where there will be a unique roll_num for a individual students. During this scenario we should not use the singleton Pattern.\n\nWhen to use this Pattern ?\n\nWhenever we are creating a class to share the common values , at that scenario we can use this kind of pattern.\n\nImplementation :\n\n\n   Method 1:\n\n\nclass SingleTon: \n  # Creating a static private variable\n  _instance = None \n  # __new__ is called inside __init__ for object instantiation. \n  def __new__(self): \n    if( not self._instance ): \n      self._instance = super(SingleTon, self).__new__(self) \n      self.y = 10 \n    return self._instance \n\nobj1 = SingleTon()\nprint(obj1.y)\nobj1.y = 30\nobj2 = SingleTon()\nprint(obj2.y)\n\n\n\nOutput:\n\n\n\n  Method 2:\n\n\ndef singleton(Class): \n  instances = {} \n  def getInstances(*args, **kwargs): \n    if Class not in instances: \n      instances[Class] = Class(*args, **kwargs) \n    return instances[Class] \n  return getInstances \n\n@singleton\nclass Test:\n  def __init__(self):\n    self.val = 10\n\nobj1 = Test()\nprint(obj1.y)\nobj1.y = 30\nobj2 = Test()\nprint(obj2.y)\n\n\n\n\n\nOutput:\n\n\nReferences:\n\n\n  __ new __ dunder methos :  Link \n  Regractoring Guru : Link\n\n\nFollow us on Instagram to support us and receive more content :  Instagram \n",
        "url": "//designpatterns/2020/06/09/DWA1011-Singleton-Design-Pattern/"
      },
    
      {
        "title": "DWA1012 - Sum of Elements in a Given Range.",
        "excerpt": "Mathematical Way to Compute SUM of numbers in a given range\n",
        "content": "Consider a Problem Statement to calculate sum of numbers between the given range(a, b).\n\nSolution 1:\nFind all the numbers within the given range and sum it all together.\ndef find_sum(a, b):\n    res = 0\n    if( a &lt; b ):\n        for item in range(a, b+1):\n            res += item\n    else:\n        for item in range(b, a+1):\n            res += item\n    return res\n\n\nBut this will be O(n)\n\nSolution 2:\nUsing the mathematical approach,\n\n\n  ### S = ((β−α+1)*(α+β))/2\n\n\ndef find_sum(a, b):\n    res = ((a - b + 1)*(a+b))/2\n    return res\n\n\nThis is one of the best solution with O(1)\n",
        "url": "//interview/2020/08/16/DWA1012-Sum-of-elements-in-a-given-range/"
      },
    
      {
        "title": "Reversing a Singly Linked List",
        "excerpt": "Reversing a Linked Lists\n",
        "content": "# Node Class:\n#   --parameter \n#  data - Value to be stored in the Node\n#  next - Link to the next node ( address of the next node )  \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n# Singly Linked List\nclass SLinkedList:\n    def __init__(self):\n        # Initializing a Head Node with value as \"Head\" for easy tracking.\n        self.head = Node(\"Head\")\n    \n    def push(self, Node):\n        # Inserting a Node.\n        temp = self.head # setting the head node to temp \n        while temp.next != None: # Traversing to find the last node\n            temp = temp.next\n        temp.next = Node # setting the value of the node\n        Node.next = None\n    \n    def print_list(self):\n        # Objective is to traverse the node. \n        # Traversing the node from the head node till the None one.\n        traverse = self.head\n        while traverse.next != None:\n            print( traverse.data , \"-&gt; \" , end=\"\") # Fancy Printing of the node list\n            traverse = traverse.next\n        print(traverse.data) # Printing the last node\n    \n    def reverse(self):\n        # Objective is to reverse the entire list.\n        # First we will think of the procedures for a single node. \n        # Head -&gt; Node_1 -&gt; ....\n        # For Node_1 to be reversed, we need to set the prev node.\n        # and to save the next node.\n        # Initialize prev to None\n        # set Node_1 to next -&gt; prev\n        # then we will iterate to the next node and do the same. \n        # At last, attach the head node to the last node. \n        prev = None\n        temp = self.head.next\n        while temp.next != None:\n            next_node = temp.next\n            curr_node = temp\n            curr_node.next = prev\n            prev = curr_node\n            temp = next_node\n        temp.next = prev\n        self.head.next = temp         \n\nlst = SLinkedList()\nlst.push( Node(8) )\nlst.push( Node(7) )\nlst.push( Node(2) )\nlst.push( Node(None) )\nlst.push( Node(9) )\nlst.print_list()\nlst.reverse()\nlst.print_list()\n\n\n",
        "url": "//data%20structures/2020/08/17/DWA1014-Reversing-a-Linked-Lists/"
      },
    
      {
        "title": "Implementing Copy Method in Singly Linked List",
        "excerpt": "Reversing a Linked Lists\n",
        "content": "# Node Class:\n#   --parameter \n#  data - Value to be stored in the Node\n#  next - Link to the next node ( address of the next node )  \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n# Singly Linked List\nclass SLinkedList:\n    def __init__(self):\n        # Initializing a Head Node with value as \"Head\" for easy tracking.\n        self.head = Node(\"Head\")\n        self.tail = self.head\n    \n    def push(self, Node):\n        if ( self.head.next == None ):\n            self.head.next = Node\n            Node.next = None\n            self.tail = Node\n        else:\n            self.tail.next = Node\n            Node.next = None\n            self.tail = Node\n    \n    def clear(self):\n        self.head.next = None\n        self.tail = self.head\n    \n    def copy(self):\n        copy_list = SLinkedList()\n        head_itr = self.head\n        copy_list.head = Node( self.head.data )\n        curr = copy_list.head\n        while head_itr.next != None:\n            head_itr = head_itr.next\n            new_node = Node(head_itr.data)\n            curr.next = new_node\n            curr = new_node\n        copy_list.tail = curr\n        return copy_list\n\n    def print_list(self):\n        traverse = self.head\n        while traverse.next != None:\n            print( traverse.data , \"-&gt; \" , end=\"\")\n            traverse = traverse.next\n        print(traverse.data)\n\n    def reverse(self):\n        # Objective is to reverse the entire list.\n        # First we will think of the procedures for a single node. \n        # Head -&gt; Node_1 -&gt; ....\n        # For Node_1 to be reversed, we need to set the prev node.\n        # and to save the next node.\n        # Initialize prev to None\n        # set Node_1 to next -&gt; prev\n        # then we will iterate to the next node and do the same. \n        # At last, attach the head node to the last node. \n        prev = None\n        temp = self.head.next\n        self.tail = temp\n        while temp.next != None:\n            next_node = temp.next\n            curr_node = temp\n            curr_node.next = prev\n            prev = curr_node\n            temp = next_node\n        temp.next = prev\n        self.head.next = temp         \n\nlst = SLinkedList()\nlst.push( Node(8) )\nlst.push( Node(7) )\nlst.push( Node(2) )\nlst.push( Node(None) )\nlst.push( Node(9) )\nlst.push(Node(78))\n\nlst.print_list()\nlst.reverse()\nlst.print_list()\n\nsec = lst.copy()\nlst.push(Node(None))\nsec.print_list()\n\nsec.push(Node(65))\nsec.print_list()\nlst.print_list()\n\n\n",
        "url": "//data%20structures/2020/08/18/DWA1015-Implementing-Copy-method-in-singly-linked-list/"
      },
    
      {
        "title": "DWA1016 - Factory Design Pattern.",
        "excerpt": "A Design Pattern to create object without exposing the creation logic to the client.\n",
        "content": "The Factory pattern is one of the Creational design patterns.The Factory pattern is a design pattern that creates an object without exposing the creation logic to the client. It maintains the high readbility of the code and we can able to refactor it easily.\n\nFactory design pattern is a creational design pattern .\nFactory Method should be used in every situation where an application (client) depends on an interface (product) to perform a task and there are multiple concrete implementations of that interface.\n\nExample:\n\n\n  \n    Classic example: Client needs an OS \nThere are two ways of doing this. We can do it in conditional method using the if/else/for or using an another class (Factory class). Consider client is using 3 kinds of phone namely Samsung, Iphone, Nokia. We know that for samsung the os will be Android, for Iphone its IOS and for Nokia its is Windows. \nBut Instead of exposing it directly we can create an another class to give the objects required.\n  \n  \n     Your Manager in Office \nConsider your manager is a Factory Class , and you are an object. If the client asks for a python developer to your manager, he then will be searching for the candidate (Object) that is you ; and then he will be returning it to the client.\n  \n\n\nWhen to use this Pattern ?\n\nMostly in all situation we can implement this Design Pattern. The reason is simple , Increases readability, Increases Refactoring of the code, also not exposing to the client.\n\nImplementation :\n\n\n   Method 1:\n\n\n\nclass Android:\n    pass\n\nclass IOS:\n    pass\n\nclass Windows:\n    pass\n\nclass OsFactoryClass:\n    def get_os(self, mobile):\n        if( mobile == \"samsumng\" ):\n            return Android()\n        elif( mobile == \"iphone\" ):\n            return IOS()\n        elif( mobile == \"nokia\" ):\n            return Windows()\n\nos_obj = OsFactoryClass()\nos = os_obj.get_os(\"samsung\") # Android object will be returned.\n\n\n\n",
        "url": "//designpatterns/2020/09/08/DWA1016-Factory-Design-Pattern/"
      },
    
      {
        "title": "DWA1018 - Abstract Factory Design Pattern.",
        "excerpt": "A Design Pattern to create object without exposing the creation logic to the client.\n",
        "content": "The Abstract Factory pattern is one of the Creational design patterns. Abstract Factory pattern is almost similar to Factory Pattern is considered as another layer of abstraction over factory pattern. Its a Super Factory Which Creates Other Factories.\n\nAbstract Factory pattern uses an interface is responsible for creating a factory of related objects without explicitly specifying their classes.\n\nExample:\n\n\n  \n    Furniture Shop \nConsider a Furniture Mart which is a Abstract Class. It has two Suppliers Supplier_1 and \nSupplier_2 . Both the Supplier implements the Furniture Mart . In turn both of the Suppliers return class objects of another class Which Implements an another FactoryPattern. \nSo the Client will be having the abstraction layer of the chair or the table produced by the suppliers.\n  \n  \n     Your SPM in Office \nConsider your Senior Project Manager is a Factory Class which creates other Factories (Manager) and you are an object. If the client asks for a python developer to your SPM, he then will be asking Project Manager , then he will be searching for the candidate (Object) that is you ; and then he will be returning it to the client.\n  \n\n\nImplementation :\n\n\n   Method 1:\n\n\n\nfrom abc import ABCMeta, abstractmethod\n\n\nclass FurnitureMart(metaclass=ABCMeta):\n    @abstractmethod\n    def create_chair(self):\n        pass\n\n    @abstractmethod\n    def create_table(self):\n        pass\n\n\nclass Supplier_1(FurnitureMart):\n    def create_chair(self):\n        return CreateChairType_1()\n\n    def create_table(self):\n        return CreateTableType_1()\n\n\nclass Supplier_2(FurnitureMart):\n    def create_chair(self):\n        return CreateChairType_2()\n\n    def create_table(self):\n        return CreateTableType_2()\n\n\nclass AbstractChair(metaclass=ABCMeta):\n    @abstractmethod\n    def size(self):\n        pass\n\n    @abstractmethod\n    def material(self):\n        pass\n\n\nclass AbstractTable(metaclass=ABCMeta):\n    @abstractmethod\n    def size(self):\n        pass\n\n    @abstractmethod\n    def material(self):\n        pass\n\n\nclass CreateChairType_1(AbstractChair):\n    def size(self):\n        return 100\n\n    def material(self):\n        return \"Wood\"\n\n\nclass CreateChairType_2(AbstractChair):\n    def size(self):\n        return 200\n\n    def material(self):\n        return \"Wool\"\n\n\nclass CreateTableType_1(AbstractTable):\n    def size(self):\n        return 123\n\n    def material(self):\n        return \"Wooden Table\"\n\n\nclass CreateTableType_2(AbstractTable):\n    def size(self):\n        return 456\n\n    def material(self):\n        return \"Stone Table\"\n\n\nif __name__ == \"__main__\":\n    print(Supplier_1(), Supplier_2())\n    for factory in (Supplier_1(), Supplier_2()):\n        chair = factory.create_chair()\n        table = factory.create_table()\n        print(f\"Chair Size {chair.size()}, Material {chair.material()}\")\n        print(f\"Table Size {table.size()}, Material {table.material()}\")\n\n\n\n",
        "url": "//designpatterns/2020/09/09/DWA1018-Abstract-Factory-Design-Pattern/"
      },
    
  
  
  
  {
    "title": "Day With Algorithm",
    "excerpt": "A Simple site which could help you to Learn and Implement Algorithms for Coding Interviews and Many More…\n",
    "content": "\nAlgorithm (வழிமுறை) is the one, which is been used by programmer when they dont want to tell their method.  Algorism is the art by which at present we use those Indian figures, which number two times five.\nThis site is been dedicated to learn and explore Computer algorithms.\n\n\n\n\n\n  \n    \n      \n        Algo and DS\n        Need to Learn Algorithms and Data Structures ?\n        AlgoDS\n      \n    \n  \n  \n    \n      \n        Weekly Contest\n        Want to Paticipate in a Contest and get Featured ?\n        Contest\n      \n    \n  \n  \n    \n      \n        Events\n        Get Notified and Participate on Upcoming events \n        Dont Miss\n      \n    \n  \n\n",
    "url": "//"
  },
  
  {
    "title": "Search",
    "excerpt": "Search for a page or post you’re looking for\n",
    "content": "{% include site-search.html %}\n",
    "url": "//search/"
  },
  
  {
    "title": "Trending Tech Youtube Videos",
    "excerpt": "Search for a page or post you’re looking for\n",
    "content": "{% include site-search.html %}\n",
    "url": "//youtube-tech/"
  }
  
]

